name: Documentation

on:
  push:
    branches:
      - main
      - master
    paths:
      - "docs/**"
      - "mkdocs.yml"
      - "src/**"
      - ".github/workflows/docs.yml"
  pull_request:
    branches:
      - main
      - master
    paths:
      - "docs/**"
      - "mkdocs.yml"
      - "src/**"
      - ".github/workflows/docs.yml"
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0 # Fetch all history for git-revision-date-localized plugin

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-docs-${{ hashFiles('**/requirements*.txt', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-docs-
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[dev]"
          pip install mkdocs mkdocs-material mkdocstrings[python] mkdocs-git-revision-date-localized-plugin mkdocs-git-committers-plugin-2 mkdocs-minify-plugin

      - name: Verify MkDocs configuration
        run: |
          mkdocs --version
          mkdocs config

      - name: Build documentation
        run: |
          mkdocs build --verbose --clean --strict

      - name: Upload documentation artifacts
        uses: actions/upload-artifact@v3
        with:
          name: documentation
          path: site/

      - name: Setup Pages
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        uses: actions/configure-pages@v3

      - name: Upload to GitHub Pages
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        uses: actions/upload-pages-artifact@v2
        with:
          path: site/

  # Deployment job
  deploy:
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v2

  # Link checker job (runs on PRs and pushes)
  link-check:
    runs-on: ubuntu-latest
    needs: build
    if: always() && needs.build.result == 'success'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download documentation artifacts
        uses: actions/download-artifact@v3
        with:
          name: documentation
          path: site/

      - name: Check internal links
        uses: lycheeverse/lychee-action@v1.8.0
        with:
          args: --verbose --no-progress --exclude-all-private --exclude-mail 'site/**/*.html'
          fail: false # Don't fail the workflow on broken links, just report them

      - name: Create link check report
        if: always()
        run: |
          echo "Link check completed. Check the logs above for any broken links."
          echo "Note: External link checking is disabled to avoid rate limiting."

  # Documentation quality check
  quality-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[dev]"
          pip install mkdocs mkdocs-material mkdocstrings[python]

      - name: Check documentation structure
        run: |
          echo "Checking documentation structure..."

          # Check that all navigation items exist
          python -c "
          import yaml
          import os

          with open('mkdocs.yml', 'r') as f:
              config = yaml.safe_load(f)

          def check_nav_item(item, path=''):
              if isinstance(item, dict):
                  for key, value in item.items():
                      if isinstance(value, str):
                          file_path = os.path.join('docs', value)
                          if not os.path.exists(file_path):
                              print(f'Missing file: {file_path}')
                              return False
                      elif isinstance(value, list):
                          for subitem in value:
                              if not check_nav_item(subitem, path + '/' + key):
                                  return False
              elif isinstance(item, str):
                  file_path = os.path.join('docs', item)
                  if not os.path.exists(file_path):
                      print(f'Missing file: {file_path}')
                      return False
              return True

          nav = config.get('nav', [])
          all_good = True
          for item in nav:
              if not check_nav_item(item):
                  all_good = False

          if all_good:
              print('All navigation files exist!')
          else:
              exit(1)
          "

      - name: Check for broken internal references
        run: |
          echo "Checking for broken internal references..."

          # Simple check for common markdown link patterns
          find docs/ -name "*.md" -exec grep -l "\[.*\](.*\.md)" {} \; | while read file; do
            echo "Checking internal links in $file"
            grep -o "\[.*\](.*\.md[^)]*)" "$file" | while read link; do
              # Extract the file path from the link
              path=$(echo "$link" | sed 's/.*](\([^)]*\)).*/\1/' | sed 's/#.*//')
              if [[ "$path" == *".md" ]]; then
                # Convert relative path to absolute
                dir=$(dirname "$file")
                if [[ "$path" == /* ]]; then
                  # Absolute path from docs root
                  full_path="docs${path}"
                else
                  # Relative path
                  full_path="$dir/$path"
                fi
                
                # Normalize path
                full_path=$(realpath -m "$full_path" 2>/dev/null || echo "$full_path")
                
                if [[ ! -f "$full_path" ]]; then
                  echo "Broken link in $file: $link -> $full_path"
                fi
              fi
            done
          done

      - name: Validate YAML frontmatter
        run: |
          echo "Validating YAML frontmatter..."

          find docs/ -name "*.md" | while read file; do
            # Check if file starts with YAML frontmatter
            if head -1 "$file" | grep -q "^---$"; then
              # Extract and validate YAML
              sed -n '2,/^---$/p' "$file" | head -n -1 | python -c "
          import sys
          import yaml
          try:
              yaml.safe_load(sys.stdin.read())
              print('Valid YAML in $file')
          except yaml.YAMLError as e:
              print('Invalid YAML in $file: ' + str(e))
              sys.exit(1)
          " || echo "YAML validation failed for $file"
            fi
          done

  # Spell check (optional, can be enabled later)
  spell-check:
    runs-on: ubuntu-latest
    if: false # Disabled by default, set to true to enable
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Spell check
        uses: streetsidesoftware/cspell-action@v5
        with:
          files: "docs/**/*.md"
          config: ".cspell.json"
          incremental_files_only: false
